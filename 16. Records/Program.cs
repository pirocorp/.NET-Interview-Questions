namespace Records
{
    public static class Program
    {
        public static void Main()
        {
            var point = new PointClass(10, 20);

            Console.WriteLine(point);

            var pointRecord = new PointRecord(1, 2);
            // Records offer a mechanism for non destructive mutation
            var pointRecord2 = pointRecord with { Y = 10 };

            // Deconstruction
            var (x, y) = pointRecord2;

            var pointA = new PointRecord(5, 5);
            var pointB = new PointRecord(5, 5);

            Console.WriteLine(pointA == pointB);
            Console.WriteLine(pointA.Equals(pointB));
        }
    }

    /// <summary cref="PointClass">
    /// Simple Point structure that is compared by value, same behavior as PointClass
    /// </summary>
    /// <param name="X"></param>
    /// <param name="Y"></param>
    public record PointRecord(int X, int Y); // Positional record (without a body)

    /// <summary>
    /// Simple Point structure that is compared by value
    /// </summary>
    public class PointClass : IEquatable<PointClass> // If we use type specific method for determining equality we must implement IEquatable<TSpecific> interface
    {
        public PointClass(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }

        public int X { get; }

        public int Y { get; }

        // Implementing IEquatable<TSpecific> interface
        public bool Equals(PointClass? other)
        {
            return other is not null
                && other.X == this.X && other.Y == this.Y;
        }

        public override bool Equals(object? obj)
        {
            // using type specific method for determining equality
            return obj is PointClass point
                && Equals(point);
        }

        // When overriding GetHashCode we must override and Equals.
        // Can be safe used as a Key in HashTable collections like Dictionary
        public override int GetHashCode()
        {
            return HashCode.Combine(this.X, this.Y);
        }

        public override string ToString()
        {
            return $"X: {this.X}, Y: {this.Y}";
        }
    }

    // GetHashCode(), Equals(), and ToString() are still generated by the compiler,
    // the comparison is still done by value, NOT by reference.
    public record PointNonPositionalRecord
    {
        public PointNonPositionalRecord(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }

        public int X { get; } // can be read-write

        public int Y { get; }

        public int Sum() // we can add methods to records
        {
            return this.X + this.Y;
        }
    }

    public readonly record struct RecordStructPointImmutable(int X, int Y);

    public record struct RecordStructPointMutable(int X, int Y);

}
